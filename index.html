<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Audio Recorder — WAV Only</title>
<meta name="description" content="Record WAV (10s max) and upload to Google Drive. Start/Stop toggle, optional Reset. Filename uses userID+gender+age+timestamp." />
<link rel="icon" href="data:,">
<style>
  :root { --w: 880px; }
  html,body { height: 100%; }
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
         margin: 0; padding: 2.5rem 1rem; display: grid; place-items: start center; background: #fafafa; color:#111; }
  main { width: min(var(--w), 100%); background: white; border: 1px solid #e5e5e5; border-radius: 12px;
         padding: 1.25rem 1.25rem 1.5rem; box-shadow: 0 4px 30px rgba(0,0,0,.04); }
  h1 { margin: .25rem 0 .25rem; font-size: clamp(1.2rem, 1.1rem + 1.2vw, 1.9rem); }
  p.lead { margin: 0 0 .75rem; color:#4b5563; }
  .row { display:flex; align-items:center; gap:.6rem; margin:.75rem 0; flex-wrap:wrap; }
  .col { display:flex; flex-direction:column; gap:.6rem; }
  button, .button { appearance: none; border: 0; background:#1f6feb; color:white; padding:.6rem .95rem;
                    border-radius:8px; font-weight:600; cursor:pointer; text-decoration:none; }
  button.secondary { background:#6b7280; }
  button.danger { background:#b91c1c; }
  button[disabled], .button[aria-disabled="true"] { opacity:.55; cursor:not-allowed; }
  #status { font-weight:600; }
  #meter { width: 320px; height: 12px; background:#eee; border-radius: 6px; overflow:hidden; border:1px solid #ddd; }
  #bar { height: 100%; width: 0%; background:#4a90e2; }
  audio { width: 100%; }
  .pill { font: 12px/1.8 system-ui; padding:.1rem .5rem; border:1px solid #e5e7eb; border-radius:999px; color:#374151;}
  .muted { color:#666; }
  input[type="number"], input[type="text"] { padding:.5rem .6rem; border:1px solid #d1d5db; border-radius:8px; }
  input#userID { width: 100px; text-transform: uppercase; }
  .hr { height:1px; background: repeating-linear-gradient(90deg,#e5e7eb, #e5e7eb 8px, transparent 8px, transparent 16px); margin: 1rem 0; }
  footer { margin-top: .5rem; font-size:.9rem; color:#555; display:flex; justify-content:space-between; gap:.5rem; flex-wrap:wrap; }
  .formlabel { font-size:.9rem; color:#374151; }
  .options { display:flex; align-items:center; gap:.8rem; }
  .options label { display:flex; align-items:center; gap:.25rem; cursor:pointer; }
  #countdown { min-width: 4ch; text-align: right; }
</style>
</head>
<body>
<main>
  <h1>Audio Recorder — WAV Only</h1>
  <p class="lead">Filename: <code>userID_G_AGE_audio_dd_mm_yyyy_hh_mm_ss.wav</code> • Max length: <strong>10s</strong> (you can stop earlier)</p>

  <div class="row" aria-label="metadata">
    <label class="formlabel" for="userID">User ID (A123):</label>
    <input id="userID" type="text" placeholder="A123" maxlength="4" pattern="[A-Za-z][0-9]{3}" aria-label="User ID one letter + three digits" />
    <div class="options">
      <span class="formlabel">Gender:</span>
      <label><input type="radio" name="gender" value="M" id="gM"> M</label>
      <label><input type="radio" name="gender" value="F" id="gF"> F</label>
      <label><input type="radio" name="gender" value="X" id="gX"> Other</label>
    </div>
    <label class="formlabel" for="age">Age:</label>
    <input id="age" type="number" placeholder="00" min="0" max="120" step="1" />
  </div>

  <div class="row" aria-label="controls">
    <button id="recordToggleBtn">Start recording</button>
    <button id="resetBtn" class="danger" disabled>Reset</button>
    <span id="status" class="pill">idle</span>
    <span id="sr" class="pill"></span>
    <span id="countdown" class="pill">10.0s</span>
  </div>

  <div class="row" aria-label="input-level">
    <strong>Input level</strong>
    <div id="meter"><div id="bar"></div></div>
  </div>

  <div class="col" style="align-items:stretch;" aria-label="playback">
    <audio id="player" controls></audio>
    <div class="row" style="justify-content:space-between;">
      <a id="download" class="button" download="recording.wav">Download .wav</a>
      <span id="sizeHint" class="muted"></span>
    </div>
  </div>

  <div class="hr" role="separator"></div>

  <div class="col" aria-label="drive-upload">
    <button id="uploadBtn" disabled>Upload</button>
  </div>

  <footer>
    <span>Built with <code>getUserMedia</code> + <code>AudioWorklet</code>/<code>ScriptProcessor</code>. Exports <code>audio/wav</code> only.</span>
    <span><a href="README.md">Setup guide</a></span>
  </footer>
</main>

<!-- ***** All JavaScript is inside this script tag ***** -->
<script type="module">
// === CONFIG: paste your Apps Script Web App URL here ===
const WEB_APP_URL = 'https://script.google.com/macros/s/AKfycbz4BwQs2SkQ8Z1C4bG33rDPn1nZG4g_wAvVPYI_soEVXMtNZNDNL0Qf6Szx9jpE__TNNw/exec';
// =======================================================

let audioCtx, stream, meterRAF;
let leftBuffers = [];  // mono accumulation (Float32)
let sampleRate = 48000;
let recording = false;
let stopTimer = null;
let countdownRAF = null;
let startTs = 0;

const MAX_SECONDS = 10.0;

const recordBtn = document.getElementById('recordToggleBtn');
const resetBtn  = document.getElementById('resetBtn');
const statusEl  = document.getElementById('status');
const srEl      = document.getElementById('sr');
const player    = document.getElementById('player');
const link      = document.getElementById('download');
const bar       = document.getElementById('bar');
const sizeHint  = document.getElementById('sizeHint');
const uploadBtn = document.getElementById('uploadBtn');
const countdown = document.getElementById('countdown');

function setStatus(s) { statusEl.textContent = s; }
function setSr() { srEl.textContent = 'SampleRate: ' + sampleRate + ' Hz'; }

function currentUserID() {
  const raw = (document.getElementById('userID').value || '').trim().toUpperCase();
  return /^[A-Z][0-9]{3}$/.test(raw) ? raw : 'U000';
}
function currentGender() {
  const sel = document.querySelector('input[name="gender"]:checked');
  const v = sel ? sel.value : 'X';
  return (v === 'M' || v === 'F') ? v : 'X';
}
function currentAge2() {
  const n = parseInt((document.getElementById('age').value || '').trim(), 10);
  if (isNaN(n) || n < 0 || n > 120) return '00';
  return String(n).padStart(2, '0');
}

function startMeter(analyser) {
  function tick() {
    const data = new Uint8Array(analyser.fftSize);
    analyser.getByteTimeDomainData(data);
    let sum = 0;
    for (let i=0; i<data.length; i++) {
      const v = (data[i] - 128) / 128;
      sum += v*v;
    }
    const rms = Math.sqrt(sum / data.length);
    bar.style.width = Math.min(100, Math.round(rms * 200)) + '%';
    meterRAF = requestAnimationFrame(tick);
  }
  tick();
}
function stopMeter() { if (meterRAF) cancelAnimationFrame(meterRAF); }

function interleaveMono(buffers) {
  const length = buffers.reduce((a,b)=>a+b.length, 0);
  const out = new Float32Array(length);
  let offset = 0;
  for (const b of buffers) { out.set(b, offset); offset += b.length; }
  return out;
}
function floatTo16BitPCM(float32) {
  const out = new DataView(new ArrayBuffer(float32.length * 2));
  let offset = 0;
  for (let i=0; i<float32.length; i++, offset+=2) {
    let s = Math.max(-1, Math.min(1, float32[i]));
    out.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return out;
}
function writeWavHeader(view, sampleRate, numSamples, numChannels = 1, bitsPerSample = 16) {
  function writeString(view, offset, str) { for (let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i)); }
  const blockAlign = numChannels * bitsPerSample/8;
  const byteRate = sampleRate * blockAlign;
  const dataSize = numSamples * blockAlign;
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitsPerSample, true);
  writeString(view, 36, 'data');
  view.setUint32(40, dataSize, true);
}
function encodeWav(buffers, sampleRate) {
  const mono = interleaveMono(buffers);
  const pcm16 = floatTo16BitPCM(mono);
  const header = new DataView(new ArrayBuffer(44));
  writeWavHeader(header, sampleRate, mono.length, 1, 16);
  const wavBytes = new Uint8Array(44 + pcm16.byteLength);
  wavBytes.set(new Uint8Array(header.buffer), 0);
  wavBytes.set(new Uint8Array(pcm16.buffer), 44);
  return new Blob([wavBytes], { type: 'audio/wav' });
}

function updateCountdown() {
  if (!recording) { countdown.textContent = MAX_SECONDS.toFixed(1)+'s'; return; }
  const elapsed = (performance.now() - startTs) / 1000;
  const left = Math.max(0, MAX_SECONDS - elapsed);
  countdown.textContent = left.toFixed(1) + 's';
  countdownRAF = requestAnimationFrame(updateCountdown);
}

async function setupAudio() {
  const AC = window.AudioContext || window.webkitAudioContext;
  audioCtx = new AC();
  sampleRate = audioCtx.sampleRate;
  setSr();

  stream = await navigator.mediaDevices.getUserMedia({ audio: true });
  const src = audioCtx.createMediaStreamSource(stream);

  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 2048;
  src.connect(analyser);
  startMeter(analyser);

  leftBuffers = [];
  if (audioCtx.audioWorklet) {
    try {
      await audioCtx.audioWorklet.addModule('recorder-worklet.js');
      const node = new AudioWorkletNode(audioCtx, 'wav-recorder-processor');
      src.connect(node);
      node.port.onmessage = (e) => {
        if (!recording) return;
        if (e.data && e.data.type === 'chunk') {
          leftBuffers.push(new Float32Array(e.data.samples));
          const seconds = leftBuffers.reduce((acc,b)=>acc+b.length,0) / sampleRate;
          sizeHint.textContent = 'Length: ' + seconds.toFixed(1) + ' s';
        }
      };
      return;
    } catch (e) {
      console.warn('AudioWorklet failed, falling back to ScriptProcessor:', e);
    }
  }
  const sp = audioCtx.createScriptProcessor(4096, 1, 1);
  src.connect(sp);
  sp.connect(audioCtx.destination);
  sp.onaudioprocess = (ev) => {
    if (!recording) return;
    const input = ev.inputBuffer.getChannelData(0);
    leftBuffers.push(new Float32Array(input));
    const seconds = leftBuffers.reduce((acc,b)=>acc+b.length,0) / sampleRate;
    sizeHint.textContent = 'Length: ' + seconds.toFixed(1) + ' s';
  };
}

function pad2(n){ return String(n).padStart(2,'0'); }
function buildFilename() {
  const user = currentUserID();      // A123 or U000
  const g = currentGender();         // M/F/X
  const age = currentAge2();         // 00..99
  const d = new Date();
  const dd = pad2(d.getDate()), mm = pad2(d.getMonth()+1), yyyy = d.getFullYear();
  const hh = pad2(d.getHours()), mi = pad2(d.getMinutes()), ss = pad2(d.getSeconds());
  const stamp = `${dd}_${mm}_${yyyy}_${hh}_${mi}_${ss}`;
  return `${user}_${g}_${age}_audio_${stamp}.wav`;
}

function finalizeRecording() {
  setStatus('encoding…');
  if (stream) stream.getTracks().forEach(t=>t.stop());
  stopMeter();
  const blob = encodeWav(leftBuffers, sampleRate);
  const url = URL.createObjectURL(blob);
  player.src = url;
  const filename = buildFilename();
  link.href = url;
  link.download = filename;
  sizeHint.textContent = 'Size: ' + (blob.size/1024/1024).toFixed(2) + ' MB';
  setStatus('ready');
  recordBtn.disabled = false;
  recordBtn.textContent = 'Start recording';
  resetBtn.disabled = false;
  uploadBtn.disabled = false;
  window.__latestBlob = blob;
  window.__latestFilename = filename;
}

function startRecording() {
  recording = true;
  leftBuffers = [];
  startTs = performance.now();
  updateCountdown();
  setStatus('recording…');
  recordBtn.textContent = 'Stop recording';
  recordBtn.disabled = false;      // keep enabled so user can stop
  resetBtn.disabled = false;
  uploadBtn.disabled = true;

  // Hard cap at 10s
  stopTimer = setTimeout(() => {
    if (recording) stopRecording();
  }, Math.ceil(MAX_SECONDS * 1000));
}

function stopRecording() {
  if (!recording) return;
  recording = false;
  if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
  if (countdownRAF) cancelAnimationFrame(countdownRAF);
  countdown.textContent = MAX_SECONDS.toFixed(1) + 's';
  finalizeRecording();
}

recordBtn.addEventListener('click', async () => {
  try {
    if (!recording) {
      // start
      recordBtn.disabled = true;     // briefly disable to avoid double-click race
      player.src = ''; link.href = ''; sizeHint.textContent = '';
      await setupAudio();
      if (audioCtx.state === 'suspended') await audioCtx.resume();
      startRecording();
    } else {
      // stop early (shorter than 10s)
      stopRecording();
    }
  } catch (e) {
    console.error(e);
    setStatus('permission denied or unavailable');
    alert('Microphone access failed. Check browser permissions and HTTPS.');
    recordBtn.disabled = false;
    recordBtn.textContent = 'Start recording';
    resetBtn.disabled = true;
  }
});

resetBtn.addEventListener('click', () => {
  // Cancel and clear UI (discard the take)
  if (stopTimer) { clearTimeout(stopTimer); stopTimer = null; }
  if (countdownRAF) cancelAnimationFrame(countdownRAF);
  countdown.textContent = MAX_SECONDS.toFixed(1) + 's';
  recording = false;
  try { if (stream) stream.getTracks().forEach(t=>t.stop()); } catch {}
  stopMeter();
  leftBuffers = [];
  window.__latestBlob = null;
  window.__latestFilename = null;
  player.src = ''; link.href = ''; sizeHint.textContent = '';
  setStatus('idle');
  recordBtn.disabled = false;
  recordBtn.textContent = 'Start recording';
  resetBtn.disabled = true;
  uploadBtn.disabled = true;
});

async function blobToBase64(blob) {
  const buf = await blob.arrayBuffer();
  let binary = '';
  const bytes = new Uint8Array(buf);
  const chunk = 0x8000;
  for (let i=0; i<bytes.length; i+=chunk) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i+chunk));
  }
  return btoa(binary);
}

/* ===== Improved upload with full error reporting ===== */
uploadBtn.addEventListener('click', async () => {
  try {
    if (!WEB_APP_URL || WEB_APP_URL.includes('PASTE_')) {
      alert('Website not configured: missing Apps Script URL. Set WEB_APP_URL in index.html.');
      return;
    }
    if (!window.__latestBlob) {
      alert('Record something first.');
      return;
    }

    uploadBtn.disabled = true;
    const originalText = uploadBtn.textContent;
    uploadBtn.textContent = 'Uploading…';

    const base64 = await blobToBase64(window.__latestBlob);
    const filename = window.__latestFilename || buildFilename();

    const res = await fetch(WEB_APP_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ filename, mimeType: 'audio/wav', data: base64 })
    });

    const raw = await res.text();
    let data = null;
    try { data = JSON.parse(raw); } catch (_) {}

    if (!res.ok) {
      throw new Error(`HTTP ${res.status} ${res.statusText}\n${raw}`);
    }
    if (!data || data.ok !== true) {
      const msg = data && data.error ? data.error : `Unexpected response: ${raw}`;
      throw new Error(msg);
    }

    alert('Uploaded ✓\n' + (data.finalName || filename));
  } catch (e) {
    console.error('Upload failed:', e);
    alert('Upload failed:\n' + e.message);
  } finally {
    uploadBtn.textContent = 'Upload';
    uploadBtn.disabled = false;
  }
});
</script>
<!-- ***** End of script ***** -->

</body>
</html>
